content_assist_disabled_computers=org.eclipse.jdt.ui.textProposalCategory\u0000org.eclipse.jdt.ui.javaPostfixProposalCategory\u0000org.eclipse.jdt.ui.javaAllProposalCategory\u0000org.eclipse.jdt.ui.javaTypeProposalCategory\u0000org.eclipse.jdt.ui.javaNoTypeProposalCategory\u0000org.eclipse.jdt.ui.javaChainProposalCategory\u0000
content_assist_lru_history=<?xml version\="1.0" encoding\="UTF-8" standalone\="no"?><history maxLHS\="100" maxRHS\="10"><lhs name\="java.util.Map"><rhs name\="java.util.TreeMap"/><rhs name\="java.util.HashMap"/></lhs><lhs name\="java.lang.Cloneable"><rhs name\="java.util.TreeMap"/><rhs name\="java.util.LinkedHashSet"/><rhs name\="java.util.HashMap"/><rhs name\="java.util.HashSet"/><rhs name\="java.util.ArrayList"/></lhs><lhs name\="java.util.AbstractMap"><rhs name\="java.util.TreeMap"/><rhs name\="java.util.HashMap"/></lhs><lhs name\="java.util.HashMap"><rhs name\="java.util.HashMap"/></lhs><lhs name\="java.util.List"><rhs name\="java.util.ArrayList"/></lhs><lhs name\="java.util.Collection"><rhs name\="java.util.PriorityQueue"/><rhs name\="java.util.LinkedList"/><rhs name\="java.util.LinkedHashSet"/><rhs name\="java.util.HashSet"/><rhs name\="java.util.ArrayList"/></lhs><lhs name\="java.lang.Iterable"><rhs name\="java.util.PriorityQueue"/><rhs name\="java.util.LinkedList"/><rhs name\="java.util.LinkedHashSet"/><rhs name\="java.util.HashSet"/><rhs name\="java.util.ArrayList"/></lhs><lhs name\="java.util.RandomAccess"><rhs name\="java.util.ArrayList"/></lhs><lhs name\="java.util.AbstractList"><rhs name\="java.util.ArrayList"/></lhs><lhs name\="java.util.AbstractCollection"><rhs name\="java.util.PriorityQueue"/><rhs name\="java.util.LinkedHashSet"/><rhs name\="java.util.HashSet"/><rhs name\="java.util.ArrayList"/></lhs><lhs name\="java.util.ArrayList"><rhs name\="java.util.ArrayList"/></lhs><lhs name\="java.util.Set"><rhs name\="java.util.LinkedHashSet"/><rhs name\="java.util.HashSet"/></lhs><lhs name\="java.util.AbstractSet"><rhs name\="java.util.LinkedHashSet"/><rhs name\="java.util.HashSet"/></lhs><lhs name\="java.util.HashSet"><rhs name\="java.util.LinkedHashSet"/><rhs name\="java.util.HashSet"/></lhs><lhs name\="java.util.NavigableMap"><rhs name\="java.util.TreeMap"/></lhs><lhs name\="java.util.SortedMap"><rhs name\="java.util.TreeMap"/></lhs><lhs name\="java.util.TreeMap"><rhs name\="java.util.TreeMap"/></lhs><lhs name\="B$pair"><rhs name\="B$pair"/></lhs><lhs name\="java.util.Queue"><rhs name\="java.util.PriorityQueue"/><rhs name\="java.util.LinkedList"/></lhs><lhs name\="cycleDetectionBFS$pair"><rhs name\="cycleDetectionBFS$pair"/></lhs><lhs name\="java.util.AbstractQueue"><rhs name\="java.util.PriorityQueue"/></lhs><lhs name\="java.util.PriorityQueue"><rhs name\="java.util.PriorityQueue"/></lhs><lhs name\="C$pair"><rhs name\="C$pair"/></lhs><lhs name\="java.util.LinkedHashSet"><rhs name\="java.util.LinkedHashSet"/></lhs><lhs name\="A$pair"><rhs name\="A$pair"/></lhs><lhs name\="java.awt.ItemSelectable"><rhs name\="java.awt.List"/></lhs><lhs name\="javax.accessibility.Accessible"><rhs name\="java.awt.List"/></lhs><lhs name\="java.awt.Component"><rhs name\="java.awt.List"/></lhs><lhs name\="java.awt.image.ImageObserver"><rhs name\="java.awt.List"/></lhs><lhs name\="java.awt.MenuContainer"><rhs name\="java.awt.List"/></lhs><lhs name\="java.awt.List"><rhs name\="java.awt.List"/></lhs></history>
content_assist_number_of_computers=18
eclipse.preferences.version=1
org.eclipse.jdt.ui.formatterprofiles.version=18
org.eclipse.jdt.ui.text.custom_templates=<?xml version\="1.0" encoding\="UTF-8" standalone\="no"?><templates><template autoinsert\="true" context\="java" deleted\="false" description\="imports" enabled\="true" name\="imp">import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;</template><template autoinsert\="true" context\="java" deleted\="false" description\="Boiler Plate" enabled\="true" name\="hello">// author\: Tarun Verma\nstatic FastScanner sc \= new FastScanner();\nstatic int inf \= Integer.MAX_VALUE;\nstatic long mod \= 1000000007;\n\npublic static void solve() {\n\t${word_selection}${}\n}\n\npublic static void main(String[] args) {\n\tint t \= 1;\n\tt \= sc.nextInt();\n\touter\: for (int tt \= 0; tt &lt; t; tt++) {\n\t\tsolve();\n\t}\n}\n/* Common Mistakes By Me\n * make sure to read the bottom part of question\n * special cases (n\=1?)\n * In Game Theory Check your solution and consider all the solutions\n * Always initialise value to the declare array in local scope\n * don't use debugs in interactive problems\n * Always Reset vis,adj array upto n+1 otherwise can cause TLE\n*/\n////////////////////////////////////////////////////////////////////////////////////\n////////////////////DO NOT BELOW BEFORE THIS LINE //////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////\n\nstatic boolean isPalindrom(char[] arr, int i, int j) {\n\tboolean ok \= true;\n\twhile (i &lt;\= j) {\n\t\tif (arr[i] \!\= arr[j]) {\n\t\t\tok \= false;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tj--;\n\t}\n\treturn ok;\n}\n\nstatic int max(int a, int b) {\n\treturn Math.max(a, b);\n}\n\nstatic int min(int a, int b) {\n\treturn Math.min(a, b);\n}\n\nstatic long max(long a, long b) {\n\treturn Math.max(a, b);\n}\n\nstatic long min(long a, long b) {\n\treturn Math.min(a, b);\n}\n\nstatic int abs(int a) {\n\treturn Math.abs(a);\n}\n\nstatic long abs(long a) {\n\treturn Math.abs(a);\n}\n\nstatic void swap(long arr[], int i, int j) {\n\tlong temp \= arr[i];\n\tarr[i] \= arr[j];\n\tarr[j] \= temp;\n}\n\nstatic void swap(int arr[], int i, int j) {\n\tint temp \= arr[i];\n\tarr[i] \= arr[j];\n\tarr[j] \= temp;\n}\n\nstatic int maxArr(int arr[]) {\n\tint maxi \= Integer.MIN_VALUE;\n\tfor (int x \: arr)\n\t\tmaxi \= max(maxi, x);\n\treturn maxi;\n}\n\nstatic int minArr(int arr[]) {\n\tint mini \= Integer.MAX_VALUE;\n\tfor (int x \: arr)\n\t\tmini \= min(mini, x);\n\treturn mini;\n}\n\nstatic long maxArr(long arr[]) {\n\tlong maxi \= Long.MIN_VALUE;\n\tfor (long x \: arr)\n\t\tmaxi \= max(maxi, x);\n\treturn maxi;\n}\n\nstatic long minArr(long arr[]) {\n\tlong mini \= Long.MAX_VALUE;\n\tfor (long x \: arr)\n\t\tmini \= min(mini, x);\n\treturn mini;\n}\n\nstatic int gcd(int a, int b) {\n\tif (b \=\= 0)\n\t\treturn a;\n\treturn gcd(b, a % b);\n}\n\nstatic long gcd(long a, long b) {\n\tif (b \=\= 0)\n\t\treturn a;\n\treturn gcd(b, a % b);\n}\n\nstatic void ruffleSort(int[] a) {\n\tint n \= a.length;\n\tRandom r \= new Random();\n\tfor (int i \= 0; i &lt; a.length; i++) {\n\t\tint oi \= r.nextInt(n);\n\t\tint temp \= a[i];\n\t\ta[i] \= a[oi];\n\t\ta[oi] \= temp;\n\t}\n\tArrays.sort(a);\n}\n\npublic static int binarySearch(int a[], int target) {\n\tint left \= 0;\n\tint right \= a.length - 1;\n\tint mid \= (left + right) / 2;\n\tint i \= 0;\n\twhile (left &lt;\= right) {\n\t\tif (a[mid] &lt;\= target) {\n\t\t\ti \= mid + 1;\n\t\t\tleft \= mid + 1;\n\t\t} else {\n\t\t\tright \= mid - 1;\n\t\t}\n\t\tmid \= (left + right) / 2;\n\t}\n\treturn i;\n}\n\nstatic class FastScanner {\n\tBufferedReader br \= new BufferedReader(new InputStreamReader(System.in));\n\tStringTokenizer st \= new StringTokenizer("");\n\n\tString next() {\n\t\twhile (\!st.hasMoreTokens())\n\t\t\ttry {\n\t\t\t\tst \= new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tint[] readArray(int n) {\n\t\tint[] a \= new int[n];\n\t\tfor (int i \= 0; i &lt; n; i++)\n\t\t\ta[i] \= nextInt();\n\t\treturn a;\n\t}\n\n\tint[][] read2dArray(int n, int m) {\n\t\tint arr[][] \= new int[n][m];\n\t\tfor (int i \= 0; i &lt; n; i++) {\n\t\t\tfor (int j \= 0; j &lt; m; j++) {\n\t\t\t\tarr[i][j] \= nextInt();\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t}\n\n\tArrayList&lt;Integer&gt; readArrayList(int n) {\n\t\tArrayList&lt;Integer&gt; arr \= new ArrayList&lt;Integer&gt;();\n\t\tfor (int i \= 0; i &lt; n; i++) {\n\t\t\tint a \= nextInt();\n\t\t\tarr.add(a);\n\t\t}\n\t\treturn arr;\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n}\n\nstatic class pair {\n\tint fr, sc;\n\n\tpair(int fr, int sc) {\n\t\tthis.fr \= fr;\n\t\tthis.sc \= sc;\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////////\t\n</template><template autoinsert\="true" context\="java" deleted\="false" description\="Modular Inverse" enabled\="true" name\="mod_inv">static int mod_inv(int a, int m) {\n\tint g \= m, r \=a, x \= 0, y \=1;\n\twhile(r \!\=0) {\n\t\tint q \= g /r ;\n\t\tg %\= r;\n\t\tint tmp \= g;\n\t\tg \= r;\n\t\tr \= tmp;\n\t\tx -\= (q * y);\n\t\ttmp \= x;\n\t\tx \= y;\n\t\ty \= tmp;\n\t}\n\treturn x &lt; 0 ? x + m \:  x;\n\t\n}</template><template autoinsert\="true" context\="java" deleted\="false" description\="Sieve of Eractothenes" enabled\="true" name\="sieve">static int [] Sieve(int n) {\n\tboolean [] mark \= new boolean[n+1];\n\tfor(int i \=0;i&lt;\=n;i++) {\n\t\tmark[i] \= true;\n\t}\n\n\tfor(int p \= 2;p*p &lt;\= n;p++) {\n\t\tif(mark[p] \=\= true) {\n\t\t\tfor(int i \= p*p;i&lt;\=n;i+\=p) {\n\t\t\t\tmark[i] \= false;\n\t\t\t}\n\t\t}\n\t}\n\tArrayList&lt;Integer&gt; pr \= new ArrayList&lt;Integer&gt;();\n//\tSystem.out.println("Following numbers are Prime numbers less then " + n + " \: ");\n\tfor(int i \=2;i&lt;\=n;i++) {\n\t\tif(mark[i] \=\= true) {\n//\t\t\tSystem.out.print(i + " ");\n\t\t\tpr.add(i);\n\t\t}\n\t}\n\t// number of primes under n\n\tint np[] \= new int[1000007];\n\tint j \=0 ;\n\tfor(int i \= 2;i&lt;n;i++) {\n\t\tnp[i] \= np[i-1];\n\t\tfor(;j&lt;pr.size();j++) {\n\t\t\tif(pr.get(j) &lt;\= i) {\n\t\t\t\tnp[i] ++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn np;\n}</template><template autoinsert\="true" context\="java" deleted\="false" description\="isPrime" enabled\="true" name\="isPrime">static boolean isPrime(long n) {\n\tif(n &lt;\= 1) return false;\n\tif(n &lt;\=3) return true;\n\tif(((n &amp; 1) \=\= 0) || ((n % 3) \=\= 0))\n\t\treturn false;\n\tfor(int i \=5;i*i &lt;\=n;i+\=6) {\n\t\tif(((n % i) \=\= 0) ||((n % (i + 2)) \=\= 0)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n\t\n}\n</template><template autoinsert\="true" context\="java" deleted\="false" description\="" enabled\="true" name\="allDivisers">static ArrayList&lt;Integer&gt; allDivisors(long n) {\n\tArrayList&lt;Integer&gt; arr \= new ArrayList&lt;Integer&gt;();\n//\tarr.add(1);\n\tfor(int i \= 1;i&lt;Math.sqrt(n);i++) {\n\t\tif(n % i \=\= 0) {\n\t\t\tif(n / i \=\= i) {\n\t\t\t\tarr.add(i);\n\t\t\t} else {\n\t\t\t\tarr.add(i);\n\t\t\t\tarr.add((int) (n / i));\n\t\t\t}\n\t\t}\n\t}\n\tCollections.sort(arr);\n\t\n\treturn arr;\n}\n\t</template><template autoinsert\="true" context\="java" deleted\="false" description\="A Power B" enabled\="true" name\="aToPowerBOptimised">public static long aToPowerBOptimised(long a, long b) {\n\t// Base Case\n\tif(b \=\= 0) return 1;\n\t// recursion Assumption\n\tlong sub \= aToPowerBOptimised(a, b/2) % mod;\n\tif((b &amp; 1) \=\= 0) \n\t\treturn (sub % mod * sub % mod) % mod;\n\telse\n\t\treturn (a% mod * sub% mod * sub% mod)% mod;  \n}</template></templates>
spelling_locale_initialized=true
useAnnotationsPrefPage=true
useQuickDiffPrefPage=true
